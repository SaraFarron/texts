# Что такое метаклассы в perl? Использование Class::MOP

*Что такое метаклассы. Для чего нужны метаклассы. Что такое метаобъектный протокол. Что такое <font color="#00aa00">Class::MOP</font>. Для чего используется <font color="#00aa00">Class::MOP</font>.*

## Что такое метаклассы?

В ООП метаклассом является класс, экземплярами которого являются не объекты, как обычно, а классы. Так же, как обычный класс определяет поведение некоторых объектов, метакласс определяет поведение некоторых классов и их экземпляров.

Не все языки программирования, поддерживающие парадигму ООП, поддерживают метаклассы. При этом, уровень поддержки метаклассов каждым языком может достаточно сильно отличаться. Отличаются так же и реализации протокола метаобъектов, принципы, которые управляют взаимодействием объектов, классов и метаклассов.

Среди самых популярных языков, метаклассы поддерживают: Objective-C, Python, Perl и Ruby.

Иногда идею метаклассов сравнивают с шаблоном проектирования "Фабрика".

## Для чего нужны метаклассы?

Идея метаклассов возникает в объектно-ориентированных языках программирования. С ее помощью реализуется завершенный рекурсивный дизайн системы. Удобно при работе с иерархиями классов.

Для Perl в чистом виде, идея метаклассов абсолютно чужеродная. Хотя интересна с точки зрения архитектуры и реализации.

## Что такое метаобъектный протокол?

<font color="#00aa00">Метаобъектный протокол</font> - это механизм для определения и использования новых метаклассов.

Метаобъектный протокол определяет множество функций, которые содержат методы для классов. Программирование на уровне метаобъектного протокола - это определение новых классов вместе с методами для этих классов.

## Метаклассы в perl

В чистом Perl 5 такие понятия, как пакет, класс, метод, конструктор не имеют четких различий и границ. Понятие атрибута вообще отсутствует.

Реализация метаклассов в Perl осуществляется с помощью метаобъектного протокола, который представлен системой Class::MOP. Class::MOP и метаклассы широко используются популярным Moose (Официальное определение: "Moose — расширение для Perl 5, позволяющее упростить реализацию ООП". Я не согласна с тем, что Moose что-то там упрощает. На мой взгляд, все совершенно наоборот).

Class::MOP четко разграничивает понятия классов, методов, пакетов, добавляет понятие атрибута. Moose, благодаря Class::MOP, приближает ООП в perl к общепринятым стандартам.

Т.е. по сути, Class::MOP - это больше, чем просто способ создавать метаклассы.

## Метаобъектный протокол в perl, Class::MOP

Метаобъектный протокол создает абстрактные понятия классов, методов, объектов, атрибутов. Эти абстракции могут быть использованы для проверки и управления теми элементами системы, которые они описывают.

Для неподготовленного человека все вышенаписанное звучит, как полный бред. Поэтому, лучше всего начать разбирать метаклассы и метаобъектный протокол на примерах.

Метаобъектный протокол в perl реализован модулем <font color="#00aa00">Class::MOP</font> и включает в себя 4 подпротокола:

<ul>
<li><b>Class protocol</b> - Средство управления классами. Реализуется через <font color="#00aa00">Class::MOP::Class</font> .</li>
<li><b>Attribute protocol</b> - Реализует управление атрибутами классов. Реализуется через <font color="#00aa00">Class::MOP::Attribute</font> . Может быть расширен с помощью наследования.</li>
<li><b>Method protocol</b> - Средство для работы с методами объектной системы. Реализуется через <font color="#00aa00">Class::MOP::Method</font> .</li>
<li><b>Instance protocol</b> - Обеспечивает некоторый уровень абстракции для создания экземпляров объектов. Реализуется через <font color="#00aa00">Class::MOP::Instance</font></li>
</ul>

Instance protocol сегодня рассматриваться не будет.

### Class protocol

<font color="#00aa00">Class::MOP::Class</font> - класс метаобъекта. Данный протокол является самой большой и сложной частью Class::MOP.

Class::MOP::Class является подклассом <font color="#00aa00">Class::MOP::Module</font>. Class::MOP::Module, в свою очередь, является подклассом <font color="#00aa00">Class::MOP::Package</font>. Package Protocol предоставляет абстракцию для perl-пакетов и методы для работы с пространством имен.

Class::MOP::Class предоставляет множество методов, которые можно разделить по смысловым категориям:

<ul>
<li><b>создание класса</b>
Методы этой категории создают объект Class::MOP::Class. Объект Class::MOP::Class является <a href="http://dev-lab.info/2012/10/шаблон-проектирования-singleton/">одиночкой</a> и, либо представляет какой-нибудь существующий класс, либо используется для создания класса с нуля.
Созданный объект будет являться объектом метакласса.
Если вы попробуете повторно создать объект, то просто получите ссылку на уже созданный экземпляр.</li>

<li><b>информационные методы</b>
Методы данной категории предназначены для получения информации о классе, над которым ведется работа.</li>

<li><b>методы для управления наследованием</b>
Можно получить список всех подклассов, или, наоборот, стать наследником какого-то класса. Методы работают с <font color="#00aa00">@ISA</font>.</li>

<li><b>методы для работы с методами класса</b>
Можно использовать этот тип методов, для создания методов класса, их удаления и изменения. Данные методы в своей работе будут ссылаться на объекты <font color="#00aa00">Class::MOP::Method</font>.</li>

<li><b>методы для работы с атрибутами классов</b>
Методы будут работать с объектами класса <font color="#00aa00">Class::MOP::Attribute</font>. Методы используются для задания, поиска, чтения и удаления атрибутов классов.</li>

<li><b>методы для заморозки</b>
Методы данной категории "замораживают" класс. Класс становится стабильным, не изменяемым. После этого нельзя вызвать любые методы, которые будут изменять класс, добавлять или удалять новые атрибуты, методы класса и т.п.</li>

<li><b>модификаторы метода</b>
Это возможность добавить некоторый код, который, при вызове метода класса будет исполняться до выполнения (<font color="#00aa00">before</font> модификатор), после выполнения (модификатор <font color="#00aa00">after</font>) и во время выполнения основного кода (<font color="#00aa00">around</font> модификатор).</li>
</ul>

#### Пример использования Class::MOP::Class

##### Расширение функциональности существующего класса

Существующий класс, модуль Meta.pm:

```html
package Meta;

use strict;
use Class::MOP;

my $class = Class::MOP::Class->initialize(__PACKAGE__);
sub new {
  my $type = shift;
  my $data = {};

  my $obj = bless($data, $type);

  return $obj;
}
$class->add_method( 'get_name' => sub {
  return "ok";
} );
$class->get_all_methods();
1;
```

Подключили <font color="#00aa00">Class::MOP</font>, затем использовали <font color="#00aa00">add_method</font> для создания новых методов класса. Теперь можно использовать класс. Для юзера не будет видно никакой разницы, каким образом были созданы методы.

```perl
#!/usr/bin/perl

use Meta;

my $obj = Meta->new;
my $res = $obj->get_name();
print $res."\n";
```

##### Создание нового класса

Можно создать новый класс. В одном модуле может быть создано несколько классов. А для того, чтобы задачка не была скучной, организуем наследование.

Файл модуля, Meta2.pm :

```perl
package Meta2;
 
use strict;
use Class::MOP;

my $class = Class::MOP::Class->create('MyClass');

$class->add_method('get_info' => sub { return 'text info'; });
$class->get_all_methods();
my $ext_class = Class::MOP::Class->create('MyClassExt');

# делаем MyClassExt наследником класса MyClass
$ext_class->superclasses('MyClass');

$ext_class->add_method('get_ext_info' => sub { return 'super info for you'; });
$ext_class->get_all_methods();

1;
```

Использование классов, файл meta2.pl:

```perl
#!/usr/bin/perl

use strict;
use Meta2;

my $var = MyClass->get_info;
print $var."\n";
$var = MyClassExt->get_ext_info;
print $var."\n";
$var = MyClassExt->get_info;
print $var."\n";
```

Результат запуска скрипта meta2.pl:

<pre>
> perl meta2.pl
text info
super info for you
text info
</pre>
Работает!

К тому моменту, концепция метаклассов уже стала вполне понятной.

### Attribute protocol

Атрибутный протокол - это изобретение <font color="#00aa00">Class::MOP</font>. Perl 5 не поддерживает атрибуты. Тем важнее разобраться, что это такое.

Атрибут класса или объекта - это переменная, связанная с классом или объектом. Доступ к атрибутам осуществляется по их имени. Этим атрибуты отличаются от данных, которые содержит объект, и доступ к которым осуществляется только через методы объекта.
У программиста perl закономерно возникает вопрос - нафига это нужно? Ответ: не все пользуются таким классным языком, как perl.

В некоторых объектно-ориентированных языках программирования (например, в Java) не существует глобальных переменных. В этом случае, атрибуты классов являются единственным способом хранения и использования глобальных данных.

Работа с атрибутами в <font color="#00aa00">Class::MOP::Class</font>, на мой взгляд, уродлива и не удобна. Вот пример.

Файл модуля Meta4.pm:

```perl
package Meta4;
 
use strict;
use Class::MOP;

my $class = Class::MOP::Class->create('MyClass');
$class->add_attribute(is_flag => (accessor => 'is_flag', default=> 1));
$class->get_all_attributes();

1;
```

Файл скрипта meta4.pl:

```perl
use strict;
use Meta4;

my $class = MyClass->meta->get_attribute('is_flag')->associated_class;
# задаем значение атрибуту
MyClass->meta->get_attribute('is_flag')->set_value($class, '123');
# получаем значение атрибуту
my $var = MyClass->meta->get_attribute('is_flag')->get_value($class);

print $var."\n";
```

Вывод после запуска скрипта:
<pre>
$ perl meta4.pl
123
</pre>

### Method protocol

Считается, что это это самый простой протокол. Реализован в классе <font color="#00aa00">Class::MOP::Method</font> . Класс позволяет создать объект <font color="#00aa00">Class::MOP::Method</font>, который содержит информацию о добавляемом методе класса.

В основном, методы объекта <font color="#00aa00">Class::MOP::Method</font> просто возвращают техническую информацию. Если заглянуть в исходник Class::MOP::Method, можно увидеть, что документация к модулю занимает места больше, чем код модуля.

Простой пример, в котором я использую методы Class::MOP::Method . Класс <font color="#00aa00">Class::MOP::Class</font> создает объект класса, и этот  объект является "одиночкой". Чем я и злоупотребила в примере.

Модуль Meta3.pm :

```perl
package Meta3;
 
use strict;
use Class::MOP;

my $class = Class::MOP::Class->create('MyClass');

print "PACK: ".$class."\n";
$class->add_method('get_class' => sub { 
  # данный код не создает новый объект, а вернет ссылку на уже существующий
  return Class::MOP::Class->create('MyClass');
});

$class->add_method('get_status' => sub { 
  return 'OK';
});

$class->get_all_methods();

1;
```

Скрипт meta3.pl :

```perl
#!/usr/bin/perl

use strict;
use Meta3;

my $class_obj = MyClass->get_class();
print "SCRP: ".$class_obj."\n";

my $method = $class_obj->get_method('get_status');
print $method->package_name;
```

В результате выполнения скрипта meta3.pl, мы получим данные, которые позволят убедиться, что объект класса, действительно, создается в единственном экземпляре:
<pre>
> perl meta3.pl
PACK: Class::MOP::Class=HASH(0x10ef624)
SCRP: Class::MOP::Class=HASH(0x10ef624)
MyClass
</pre>

## Заключение

На этом закончим. После изучения <font color="#00aa00">Class::MOP</font>, я стала лучше понимать принцип работы <font color="#00aa00">Moose</font>. Хотя до сих пор не понимаю, в чем ее смысл. Если вам интересно более подробно разобрать концепцию метаклассов, рекомендую почитать документацию по системе <font color="#00aa00">Lisp CLOS</font>, которая считается образцовой реализацией метаобъектного протокола.


