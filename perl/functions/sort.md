# Что такое функция sort в perl и как с ней работать

## Описание функции

<font color="#00aa00">Sort</font> - это встроенная функция perl.
<pre>sort LIST</pre>

По умолчанию, <font color="#00aa00">sort</font> сравнивает элементы переданного списка как строки, сортирует их в алфавитном порядке и возвращает отсортированный список. Если задана директива <font color="#00aa00">use locale</font>, при сортировке будут учитываться национальные установки.

<pre>sort USERSUB LIST
sort BLOCK LIST
</pre>

Суть сортировки заключается в том, чтобы брать по два элемента из списка и сравнивать их между собой, определяя, какой из этих элементов будет стоять первым в итоговом списке.

Если необходимо изменить порядок сортировки, например, сортировать список из чисел, можно задать специальный блок сортировки.

Во время работы, <font color="#00aa00">sort</font> присваивает значения из заданного списка двум специальным переменным $a и $b, и сравнивает их между собой. Эти переменные доступны в блоке сортировки.

Блок сортировки должен определить, какой из элементов должен быть "первым" в итоговом списке, и вернуть функции <font color="#00aa00">sort()</font> значение:
<ul>
<li>-1, если "первым" будет значение переменной $a,</li>
<li>1, если "первым" будет значение переменной $b,</li>
<li>0, если порядок следования не имеет значения.</li>
</ul>

Можно вместо блока сортировки написать отдельную функцию, которая будет выполнять те же
действия, и передать <font color="#00aa00">sort</font> ссылку на нее.

$a и $b являются глобальными переменными, поэтому объявлять их дополнительно не нужно.

## Примеры использования функции sort()

### Операторы &lt;=&gt; и cmp

Операторы <font color="#00aa00">&lt;=&gt;</font> и <font color="#00aa00">cmp</font> сравнивают между собой две скалярные величины и возвращают число, означающее результат сравнения.

Алгоритм работы:
<ul>
<li>если левый аргумент &lt; правый аргумент функция вернет -1</li>
<li>если левый аргумент &gt; правый аргумент функция вернет 1</li>
<li>если левый аргумент == правый аргумент функция вернет 0</li>
</ul>

Оператор <font color="#00aa00">&lt;=&gt;</font> сравнивает между собой числа.
<pre>print(1 &lt;=> 2); # вернет -1</pre>

Оператор <font color="#00aa00">cmp</font> сравнивает строки по алфавиту. Строка, начинающаяся с буквы, которая идет в алфавите раньше другой, будет считаться "меньшей" оператором сравнения.
<pre>print("alisa" cmp "jane"); # вернет -1</pre>

Операторы сравнения возвращают данные именно в таком формате, в каком это требуется функции <font color="#00aa00">sort</font>, и поэтому идеально подходят для использования при сортировке данных с ее помощью.

### Сортировка с помощью операторов &lt;=&gt; и cmp

#### Простая сортировка числового ряда

```perl
my @array = qw(1 5 10 3 7);

print join(' ', sort {$a<=>;$b} @array ); # вывод: 1 3 5 7 10
```

#### Сортировка ключей хеша по значениям

```perl
my %hash = (
        1 => 'Nino',
        10 => 'Jass',
        5 => 'Glory',
);

my @sorted_keys = sort {$hash{$a} cmp $hash{$b}} keys %hash ;
```

#### Сортировка значений хеша

<pre>print join " ", sort {$a cmp $b} values %hash;</pre>

#### Сортировка сложной структуры данных

Допустим, есть хеш с номерами телефонов сотрудников. Нужно отсортировать его по именам сотрудников.

```perl
my %hash = (
        2345 => {
                name => 'Alexa',
                office => '342',
        },
        2458 => {
                name => 'Nino',
                office => '423',
        },
        3445 => {
                name => 'Glory',
                office => '2',
        },
);

foreach my $key (sort {$hash{$a}->{name} cmp $hash{$b}->{name}} keys %hash) {
        print $key." = ".$hash{$key}->{name}."\n";
}
```

Вывод:
<pre>
2345 = Alexa
3445 = Glory
2458 = Nino
</pre>

#### Сортировка сложной структуры данных по нескольким параметрам

Отсортируем список сотрудников по именам и номерам офиса.

```perl
my %hash = (
        2345 => {
                name => 'Alexa',
                office => '342',
        },
        2458 => {
                name => 'Nino',
                office => '423',
        },
        2459 => {
                name => 'Jess',
                office => '423',
        },
        3445 => {
                name => 'Glory',
                office => '342',
        },
);

foreach my $key (sort sort_func keys %hash) {
        print $hash{$key}->{office}." = ".$hash{$key}->{name}."\n";
}

sub sort_func {
        $hash{$a}->{name} cmp $hash{$b}->{name} ||
        $hash{$a}->{office} <=> $hash{$b}->{office};
}
```

Вывод:
<pre>
342 = Alexa
342 = Glory
423 = Jess
423 = Nino
</pre>

#### Сортировка сложной структуры данных по нескольким параметрам 2

В данном примере у нас не хеш хешей, а массив хешей. Сортируем так же, по именам сотрудников и номеру офиса.

```perl
my @array = (
        {
                name => 'Alexa',
                office => '342',
        },
        {
                name => 'Nino',
                office => '423',
        },
        {
                name => 'Jess',
                office => '423',
        },
        {
                name => 'Glory',
                office => '342',
        },
);

foreach (sort sort_func @array) {
        print $_->{office}." = ".$_->{name}."\n";
}

sub sort_func {
        $a->{name} cmp $b->{name} ||
        $a->{office} <=> $b->{office};
}
```

Вывод:
<pre>
342 = Alexa
342 = Glory
423 = Jess
423 = Nino
</pre>

