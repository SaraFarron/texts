# Как Apache обрабатывает поступивший к нему запрос

<ol>
 	<li>Post-read-request</li>
 	<li>URI translation</li>
 	<li>Header parsing</li>
 	<li>Access control</li>
 	<li>Authentication</li>
 	<li>Authorization</li>
 	<li>MIME type checking</li>
 	<li>Fixup</li>
 	<li>Response</li>
 	<li>Logging</li>
 	<li>Cleanup</li>
</ol>

Основной задачей сервера Apache является обработка поступающих http-запросов.

Apache обрабатывает поступивший запрос примерно в 11 этапов. Каждому этапу соответствует определенный обработчик (модуль) Apache.

Большинство модулей предназначены для непосредственной обработки http-запроса.

mod_perl делает возможным создание модулей Apache на языке Perl для любого этапа обработки http-запроса. После создания модуля, информация о нем вносится в httpd.conf.

**Пример:**
<pre>PerlFixupHandler Apache::DB</pre>

Fixup - в приведенном примере прямо указывает, к какому этапу применять назначенный обработчик.

## 1. Post-read-request

Данный этап начинается сразу после того, как сервер получил запрос и разобрал http-заголовок. Может
использоваться для выполнения действий, которые выполняются один раз за время обработки запроса и при
этом должны быть выполнены как можно раньше.

Post-read-request выполняется еще до этапа разбора URI, поэтому <font style="color: #2f6fab;">блоки &lt;Location&gt;, &lt;Directory&gt; и &lt;Files&gt; файла httpd.conf не могут содержать директив на подключение модулей-обработчиков данной фазы</font> (например, PerlPostReadRequestHandler).

Существуют модули Apache, работающие на данном этапе. Например, модуль mod_unique_id, который создает переменную окружения UNIQUE_ID. Переменная UNIQUE_ID будет иметь уникальное значение для каждого запроса и может в дальнейшем использоваться для работы с сессионными данными.

Модуль mod_setenvif так же работает на этапе Post-read-request. <font style="color: #2f6fab;">mod_setenvif позволяет устанавливать нужные значения переменным окружения, в зависимости от того, какие данные содержали заголовки http-запроса.</font>

mod_perl использует этап post_read_request для обработки PerlPassEnv и директивы PerlSetEnv.

На данном же этапе инициируется модуль <font style="color: #2f6fab;">Апач:: StatINC, который отслеживает происходящие изменения в модулях Perl</font> и перезапускает их.
<pre>PerlInitHandler Apache::StatINC</pre>

<b><font style="color: #990000;">Примечание:</font></b>

PerlInitHandler - синоним PerlPostReadRequestHandler. Однако, если указывать PerlInitHandler в границах блока <location>, то она будет работать как синоним PerlHeaderParserHandler.</location>

## 2. URI translation

Apache разбирает URI и выявляет его соответствие существующим файлам или виртуальным документам, которые будут созданы в процессе обработки запроса. Apache выполняет работу, с помощью модуля mod_alias и директив конфигурации, таких как Alias, ScriptAlias, Redirect, AliasMatch и др.

Процесс обработки URI может быть сильно изменен модулем mod_rewrite, который подключается на этой стадии обработки запроса.

## 3. Header parsing

На данном этапе происходит разбор заголовков запроса. При необходимости можно модифицировать заголовки или предпринять действия для блокировки нежелательных посетителей (например, роботов). Для блокирования роботов может использоваться модуль Apache::BlockAgent.

## 4. Access control

На данном этапе происходит контроль доступа к ресурсам. Можно ограничить доступ к определенным
документам, основываясь, например, на IP-адресе или параметрах запрашиваемых документов (можно запретить доступ к определенным файлам и директориям, и т.п.). Можно использовать любые условия, которые не затрагивают процесс установления личности пользователя (например, ввод логина и пароля).

Если клиенту по тем или иным причинам отказано в доступе, Apache вернет для него код - 403 (FORBIDDEN) .

**Пример:**

Запрет на доступ к файлам директории /cgi-bin/admin (httpd.conf)
<pre>&lt; Location /cgi-bin/admin &gt;
deny from all
&lt; /Location &gt;
</pre>

## 5. Authentication

На данном этапе сервер пытается получить подтверждение, что пользователь именно тот, за кого он себя выдает. Для идентификации пользователей, им может быть предложена форма и предложение ввести логин и пароль.

## 6. Authorization

Этап авторизации пользователей. После заполнения пользователем авторизационной формы, сервер
может получить все необходимые данные о правах доступа пользователя к тем или иным разделам ресурса.

Если авторизация прошла не успешно, пользователь получит в ответ сообщение об ошибке -  401 (Authorization Required). Если же процесс авторизации завершился благополучно, сервер отдает требуемые документы клиенту, а браузер запоминает на время сеанса идентификационные данные пользователя (во избежания повторной авторизации на каждой странице "охраняемого" раздела).

## 7. MIME type checking

Apache по-разному обрабатывает запросы на разные типы файлов. При запросе статичных html-файлов,
сервер просто посылает клиенту их содержимое. Если было сделано обращение к CGI-скриптам - Apache
обработает их с помощью модуля mod_cgi. Обработка mod_perl программ будет выполнена с помощью
mod_perl модуля и заданных perl-обработчиков.

На данном этапе обработки запроса <font style="color: #2f6fab;">Apache пытается определить MIME type и encoding type запрашиваемого документа</font>. Кроме того, выбирает методы, согласно которым будут обработаны указанные документы.

Выбор основывается на совокупности различных данных:
<ul>
 	<li><font style="color: #2f6fab;">конфигурационных директивах сервера,</font></li>
 	<li><font style="color: #2f6fab;">расширении имени файла, </font></li>
 	<li><font style="color: #2f6fab;">анализе содержимого файла. </font></li>
</ul>
После выбора подходящего метода, Apache выбирает обработчика, который будет использоваться на следующем этапе.

По умолчанию, <font style="color: #2f6fab;">данная стадия обрабатывается модулем mod_mime</font>. mod_mime использует файл conf/mime.types и директивы AddType и AddEncoding.

Во время выполнения этапа обработки "MIME type checking" происходит установка заголовка ответа сервера - <font style="color: #2f6fab;">Content-Type</font>.

## 8. Fixup

Данный этап служит для последней возможности доступа к переменным окружающей среды и запроса перед запуском обработчиков.

Пример модуля, работающего на данной стадии обработки запроса - mod_usertrack (контроль Cookie).

## 9. Response

Клиенту отправляются несколько http-заголовков, которые передают информацию о Content-type.
Запускаются обработчики, которые либо просто читают данные из файла (запрос страндартного html-файла), либо запускают на выполнение скрипты. Полученные данные упаковываются и отсылаются клиенту.

Это <font style="color: #2f6fab;">этап, когда используются mod_cgi, Apache::Registry и другие</font> обработчики (какие - частично определяется на предыдущем этапе).

Обработчик может быть назначен для файлов определенного типа с помощью директив AddHandler и SetHandler.

**Пример:**

Подобная директива приведет к тому, что все файлы типа .html и .htm будут обрабатываться модулем <i>mod_include</i>.
<pre>AddHandler server-parsed .html .htm</pre>

**Еще пример:**

Все файлы указанной директории будут обрабатываться модулем mod_cgi и модулем Apache::Registry (элементы mod_perl).
<pre>&lt; Directory   home/aninatalie/aninatalie.ru/cgi &gt;
	SetHandler perl-script
	PerlHandler Apache::Registry
...
&lt; /Directory &gt;
</pre>
Стоит отметить, что сами директивы AddHandler и SetHandler позволяет использовать и обрабатывает модуль mod_actions.

## 10. Logging

Этап логирования. По-умолчанию, после каждого запроса в лог-файл вносится строка с информацией о
поступившем запросе и результатах выполнения.

Логирование осуществляется встроенным модулем Apache - mod_log_config. Кроме того, если возможностей стандартного обработчика не достаточно, можно использовать CPAN-модули: Apache::DBILogger или Apache::Traffic.

## 11. Cleanup

В конце каждого запроса модулям, участвующим в обработке запроса, дается возможность произвести необходимые действия по очищению окружающего пространства: освободить занятые ресурсы, удалить временные файлы и т.д.

