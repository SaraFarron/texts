# Пример простого web-сервера на основе perl и POE. Модуль POE::Component::Server::HTTP

Ниже приводится код простого web-сервера, на основе Perl и POE.

```perl
#!/usr/bin/perl
use warnings;
use strict;

use POE;
use POE::Component::Server::HTTP;
use HTTP::Status qw/RC_OK/;

POE::Component::Server::HTTP->new(
  Port           => 32080,
  ContentHandler => {"/" => \&web_handler},
  Headers => {Server => 'Simple Perl POE web-server',},
);

sub web_handler {
  my ($request, $response) = @_;

  $response->code(RC_OK);
  $response->push_header("Content-Type", "text/plain");
  $response->content("Now: ".localtime."\n\n");

  return RC_OK;
}

$poe_kernel->run();
```

Web-сервер получает запрос от клиента и отправляет в ответ текущую дату и время (в общем, он может отправлять что угодно).

Для организации работы сервера используется POE-компонента - <font color="#00aa00">POE::Component::Server::HTTP</font>. <font color="#00aa00">POE::Component::Server::HTTP</font> - это небольшой фреймворк для создания HTTP-серверов на основе POE. Разрабатывался с опорой на принципы работы Apache и mod_perl.

Указанный в примере сервер будет слушать порт <font color="#00aa00">32080</font>. Можно обратиться к нему из браузера, используя адрес <font color="#00aa00">http://localhost:32080/</font> . При обращении к корневому каталогу сервера, для генерации контента будет вызываться подпрограмма <font color="#00aa00">web_handler()</font> .

В качестве входных параметров обработчик <font color="#00aa00">web_handler()</font> получит ссылки на объекты <font color="#00aa00">HTTP::Request</font> и <font color="#00aa00">HTTP::Response</font>. Первый параметр - объект <font color="#00aa00">HTTP::Request</font>, который содержит данные о поступившем запросе. Второй - пустой объект <font color="#00aa00">HTTP::Response</font>, который наполняется данными для последующей отправки ответа клиенту.


## Этапы обработки запроса в POE::Component::Server::HTTP

<font color="#00aa00">POE::Component::Server::HTTP</font> - очень простой фреймворк, скрывающий внутри достаточно сложную логику работы сервера.

Пользователям этого модуля, при создании своего сервера остается только создать объект <font color="#00aa00">POE::Component::Server::HTTP</font> и добавить подпрограммы для обработки поступившего запроса.

Каждый запрос обрабатывается в несколько этапов. Каждый этап обрабатывается соответствующим обработчиком: <font color="#00aa00">TransHandler</font>, <font color="#00aa00">PreHandler</font>, <font color="#00aa00">ContentHandler</font>, <font color="#00aa00">ErrorHandler</font>, <font color="#00aa00">PostHandler</font>, <font color="#00aa00">StreamHandler</font>. Обработчики вызываются в перечисленном порядке.

Все обработчики, кроме <font color="#00aa00">ContentHandler</font>, являются не обязательными (Точнее, каждый уже имеет соответствующую дефолтную программу, которая выполняет возможный минимум работы). Каждый обработчик может быть переопределен.

Обработчики получают в качестве аргументов ссылки на объекты <font color="#00aa00">HTTP::Request</font> и <font color="#00aa00">HTTP::Response</font>.

Каждый обработчик должен по завершении работы вернуть одно из значений на выбор:
<ul>
<li><b>RC_OK</b> - Все хорошо, продолжаем обработку.</li>
<li><b>RC_DENY</b> - Возвращает клиенту отказ в обслуживании. Есть нюансы при работе с различными хендлерами. См. документацию.</li>
<li><b>RC_WAIT</b> - Это специальный обработчик, который приостанавливает выполнение всех других обработчиков. Для продолжения обработки надо вызвать <font color="#00aa00">$response-&gt;continue()</font> . Может оказаться полезным во время работы с тяжелыми и длительными запросами.</li>
</ul>

### TransHandler

Обработчик выполняется до того, как будет разобран URI. Это дает возможность внести в URI изменения. Выполнение TransHandler можно прервать и перейти к следующему обработчику, вызвав RC_DENY.

### PreHandler

Обработчик вызывается после TransHandler, но до ContentHandler.

### ContentHandler

Данный обработчик должен определить содержимое ответа клиенту.

Можно для разных URL задать разных обработчиков.

Если не задан обработчик для вызываемого пользователем URL, то система просто найдет ближайший подходящий обработчик и будет использовать его для подготовки ответа пользователю.

*Например, если в программе (см. пример выше) задан обработчик только для корневого каталога, то можно ввести в браузере <font color="#00aa00">http://localhost:32080/pages/12.html</font>, программа все равно будет использовать обработчик <font color="#00aa00">web_handler()</font>, и вернет в ответ текущую дату.*

Обработчик автоматически проставит <font color="#00aa00">Content-Length</font> и <font color="#00aa00">Date</font>, если они не заданы специально. При необходимости, из этого обработчика можно проставлять cookies.

### ErrorHandler

Обработчик вызывается, если на сокете возникла ошибка. Например, клиент разорвал соединение. Если возникает такая ситуация, после ErrorHandler может быть вызван PostHanlder, но TransHandler и PreHandler вызываться не будут.

### PostHandler

Этот обработчик вызывается, после того, как ответ был отправлен клиенту.

### StreamHandler

Специальный обработчик. См. документацию.

